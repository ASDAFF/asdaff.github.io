function Waves(cvs, options) {
    var rafid, self = this, paused = !0;

    function OnResizeCVS() {
        var pixelRatio = 1 / function () {
            var ratio = 1;
            return void 0 !== window.screen.systemXDPI && void 0 !== window.screen.logicalXDPI && window.screen.systemXDPI > window.screen.logicalXDPI ? ratio = window.screen.systemXDPI / window.screen.logicalXDPI : void 0 !== window.devicePixelRatio && (ratio = window.devicePixelRatio), ratio
        }();
        self.camera.aspect = window.innerWidth / window.innerHeight, self.camera.updateProjectionMatrix(), self.renderer.setSize(window.innerWidth * pixelRatio * self.options.accuracy, window.innerHeight * pixelRatio * self.options.accuracy, !1)
    }

    function animate() {
        rafid = requestAnimationFrame(animate), function (time) {
            for (var verts = self.mesh.geometry.vertices, i = 0, len = verts.length; i < len; i++) verts[i].z = Math.sin(verts[i].x * Math.PI / self.options.offset + time * self.options.speed) * Math.cos(verts[i].y * Math.PI / self.options.offset + time * self.options.speed) * self.options.height;
            self.mesh.geometry.verticesNeedUpdate = !0
        }(Date.now() / 1e3), self.options.renderCallback(self), self.renderer.render(self.scene, self.camera)
    }

    self.isOK = !1, self.defaults = {
        accuracy: 1,
        speed: .16,
        offset: 246,
        height: 30,
        color: 16777215,
        bgColor: 1644825,
        size: 1e3,
        segments: 40,
        camera: {perspective: 70, position: {x: 450, y: 40, z: 0}, lookAt: {x: 0, y: 140, z: 50}},
        fog: {enabled: !0, density: .005},
        renderCallback: function (s) {
        }
    }, self.isPaused = function () {
        return paused
    }, self.dots = [], self.isOK = function () {
        if (self.options = function extend(destination, source) {
                for (var property in source) "object" == typeof source[property] ? destination[property] = extend(destination[property], source[property]) : destination[property] = source[property];
                return destination
            }(self.defaults, options), !window.WebGLRenderingContext) return !1;
        try {
            self.renderer = new THREE.WebGLRenderer({
                canvas: cvs,
                antialias: !0
            }), self.renderer.setClearColor(self.options.bgColor), self.scene = new THREE.Scene, self.options.fog.enabled && (self.scene.fog = new THREE.FogExp2(self.options.bgColor, self.options.fog.density)), self.camera = new THREE.PerspectiveCamera(self.options.camera.perspective, window.innerWidth / window.innerHeight, 1, 1e4), self.camera.position.set(self.options.camera.position.x, self.options.camera.position.y, self.options.camera.position.z), self.lookAt = new THREE.Vector3(self.options.camera.lookAt.x, self.options.camera.lookAt.y, self.options.camera.lookAt.z), self.camera.lookAt(self.lookAt), self.scene.add(self.camera), function (elem, type, eventHandle) {
                null != elem && null != elem && (elem.addEventListener ? elem.addEventListener(type, eventHandle, !1) : elem.attachEvent ? elem.attachEvent("on" + type, eventHandle) : elem["on" + type] = eventHandle)
            }(window, "resize", OnResizeCVS), OnResizeCVS();
            var material = new THREE.MeshBasicMaterial({color: self.options.color, wireframe: !0}),
                geometry = new THREE.PlaneGeometry(self.options.size, 2 * self.options.size, self.options.segments, 2 * self.options.segments);
            self.mesh = new THREE.Mesh(geometry, material), self.mesh.rotation.x = Math.PI / 2, self.scene.add(self.mesh)
        } catch (e) {
            return !1
        }
        return !0
    }(), self.toggle = function (run) {
        return !!self.isOK && (void 0 === run ? self.toggle(!paused) : run && paused ? (paused = !1, animate()) : run || (paused = !0, cancelAnimationFrame(rafid)), !0)
    }
}

function Timeline(cvs) {
    var self = this, paused = !0, rafid = 0, mouse = {x: 0, y: 0}, canvas = cvs, ctx = null;

    function OnResize() {
        canvas.width = canvas.offsetWidth, canvas.height = canvas.offsetHeight, self.lines[0].height = self.lines[1].height = canvas.height * self.padding[1];
        var wasPaused = paused;
        self.toggle(!1), self.lines[0].reset(canvas.offsetWidth / 2 - 15), self.lines[1].reset(canvas.offsetWidth / 2 + 15), function () {
            var tl = $(".timeline"), top = tl.find("h2").outerHeight(!0);
            self.targets[0] = tl.find("article:first-of-type figure").map(function () {
                return parseInt($(this).attr("data-proc"))
            }), self.targets[1] = tl.find("article:last-of-type figure").map(function () {
                return parseInt($(this).attr("data-proc"))
            }), self.lines[0].dots = [];
            var y = top;
            tl.find("article:first figure").each(function () {
                var h = $(this).outerHeight(!0);
                self.lines[0].dots.push([$(this).outerWidth() + 0, y + h / 2 + 0]), y += h
            }), self.lines[1].dots = [], y = top, tl.find("article:last figure").each(function () {
                var h = $(this).outerHeight(!0);
                self.lines[1].dots.push([canvas.width - $(this).outerWidth() - 0, y + h / 2 + 0]), y += h
            })
        }(), self.toggle(!wasPaused)
    }

    function Line(y, color, options, mouse) {
        var self = this;

        function Point(x, y) {
            this.y = y, this.x = x, this.base = {x: x, y: y}, this.update = function (mouse, options) {
                var dx = this.x - mouse.x, dy = this.y - mouse.y,
                    alpha = 0 < (alpha = Math.atan2(dx, dy)) ? alpha : 2 * Math.PI + alpha,
                    d = options.radius / Math.sqrt(dx * dx + dy * dy);
                this.y += Math.cos(alpha) * d + (this.base.y - this.y) * options.speed, this.x += Math.sin(alpha) * d + (this.base.x - this.x) * options.speed
            }
        }

        self.color = color, self.options = options, self.mouse = mouse, self.height = 0, self.dots = [], self.y = y, self.points = [], self.reset = function (x) {
            self.points = [];
            for (var y = self.y; y < self.height; y += self.options.density) self.points.push(new Point(x, y, self.color))
        }, self.update = function () {
            for (var i = 0; i < self.points.length; i++) self.points[i].update(self.mouse, self.options)
        }
    }

    function drawCircle(p, r, color) {
        ctx.fillStyle = color, ctx.beginPath(), ctx.arc(p.x, p.y, r, 0, 2 * Math.PI, !0), ctx.closePath(), ctx.fill()
    }

    function drawLine(p1, p2) {
        ctx.beginPath(), ctx.moveTo(p1.x, p1.y), ctx.lineTo(p2.x, p2.y), ctx.stroke(), ctx.closePath()
    }

    function animate() {
        rafid = requestAnimationFrame(animate), self.lines[0].update(), self.lines[1].update(), function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var l = 0; l < 2; l++) {
                var points = self.lines[l].points;
                ctx.beginPath(), ctx.lineWidth = 3, ctx.strokeStyle = self.lines[l].color;
                ctx.moveTo(points[0].x, points[0].y);
                for (var i = 0; i < points.length - 2; i++) {
                    var point = points[i], xc = (points[i + 1].x + point.x) / 2, yc = (points[i + 1].y + point.y) / 2;
                    ctx.quadraticCurveTo(point.x, point.y, xc, yc)
                }
                ctx.stroke(), ctx.closePath(), ctx.lineWidth = 1.2, ctx.strokeStyle = self.dotColors[l][2];
                for (i = 0; i < self.lines[l].dots.length; i++) {
                    var dot = self.lines[l].dots[i],
                        id = Math.floor(self.lines[l].points.length * self.targets[l][i] / 100),
                        dot2 = [(self.lines[l].points[id].x + self.lines[l].points[id + 1].x) / 2, (self.lines[l].points[id].y + self.lines[l].points[id + 1].y) / 2],
                        p1 = {x: dot[0], y: dot[1]}, p2 = {x: dot2[0], y: dot2[1]};
                    drawLine(p1, p2), drawCircle(p2, 11, self.dotColors[l][1]), drawCircle(p2, 5.5, self.dotColors[l][0])
                }
            }
        }()
    }

    self.lines = [], self.isOK = !1, self.options = {
        speed: .1,
        density: 8,
        radius: 600
    }, self.targets = [], self.dotColors = [["#80A3C7", "rgba(19, 102, 155, 0.3)", "rgba(19, 102, 155, 0.08)", "rgba(19, 102, 155, 0.53)"], ["#7dd317", "rgba(113, 222, 15, 0.3)", "rgba(91, 164, 22, 0.12)", "rgba(113, 222, 15, 0.53)"]], self.isPaused = function () {
        return paused
    }, self.padding = [.12, .98], self.toggle = function (run) {
        return !!self.isOK && (void 0 === run ? self.toggle(!paused) : run && paused ? (paused = !1, animate()) : run || (paused = !0, cancelAnimationFrame(rafid)), !0)
    }, self.isOK = function () {
        var result = !1;
        try {
            result = !(!canvas.getContext || !(ctx = canvas.getContext("2d"))), self.lines[0] = new Line(canvas.offsetHeight * self.padding[0], self.dotColors[0][3], self.options, mouse), self.lines[1] = new Line(canvas.offsetHeight * self.padding[0], self.dotColors[1][3], self.options, mouse)
        } catch (e) {
            return !1
        }
        return $(canvas).mousemove(function (e) {
            e.offsetX ? (mouse.x = e.offsetX, mouse.y = e.offsetY) : e.layerX ? (mouse.x = e.layerX, mouse.y = e.layerY) : (mouse.x = e.pageX - $(canvas).offset().left, mouse.y = e.pageY - $(canvas).offset().top)
        }), $(window).resize(OnResize), OnResize(), result
    }()
}

debug = !!debug, function () {
    for (var b in browsers = {
        opera: [!1, "opera"],
        ie: [!1, "msie"],
        chrome: [!1, "chrome"]
    }, browsers) (browsers[b][0] = 0 <= navigator.userAgent.toLowerCase().indexOf(browsers[b][1])) && $("html").addClass(browsers[b][1]);
    var resize_seq = !1;
    $(window).resize(function (e) {
        resize_seq || (resize_seq = !0, setTimeout(function () {
            $(window).resize(), resize_seq = !1
        }, 2e3))
    })
}(), function () {
    document.querySelector("video").playbackRate = .6;
    var intro = !0;
    Visibility.onVisible(function () {
        intro && setTimeout(function () {
            $(window).resize();
            var $main = $("#main");
            $main.toggleClass("play"), $main.find("#skills-slider").yslider(["PHP", "WEB", "BITRIX", "JS"], {
                speed: 300,
                pause: 2e3,
                delay: 2e3
            }), $main.find("#like-slider").yslider(["UI Design", "Julia", "Cars", "Motorcycles", "Programming"], {
                speed: 300,
                pause: 2e3,
                delay: 2e3
            }), intro = !0
        }, 600)
    });
    var mouseX = 0, about = $("#about");
    about.mousemove(function (e) {
        mouseX = e.clientX
    });
    var waves = new Waves($("#cvs2")[0], {
        color: 1214401, renderCallback: function (v) {
            var targetX = mouseX / window.innerWidth * 200 - 100;
            v.lookAt.z += (-targetX - v.lookAt.z) / 20, v.camera.lookAt(v.lookAt)
        }
    });
    waves.isOK || $("#cvs2").addClass("no-webgl"), new Waypoint.Inview({
        element: about[0], enter: function (dir) {
            waves.toggle(!0)
        }, exited: function (dir) {
            waves.toggle(!1)
        }
    }), new Waypoint({
        element: about[0], handler: function (direction) {
            "down" === direction && $(this.element).addClass("play")
        }, offset: "40%"
    });

    // setTimeout(function () {
    //     $(document).attr("title", $("<div/>").html("&#9679; &#8226; . &nbsp; &nbsp;" + document.title).text());
    //     var n = "asdaff.asad" + "@yandex.ru";
    //     $(".email").attr("href", "mailto:" + n).attr("title", n)
    // }, 1e3),

    window.applicationCache && window.applicationCache.addEventListener("updateready", function () {
        window.location.reload()
    })
}(), function ($) {
    function CanvasRenderer(el, options) {
        var cachedBackground, canvas = document.createElement("canvas");
        "undefined" != typeof G_vmlCanvasManager && G_vmlCanvasManager.initElement(canvas);
        var ctx = canvas.getContext("2d");
        canvas.width = canvas.height = options.size, el.appendChild(canvas);
        var scaleBy = 1;
        1 < window.devicePixelRatio && (scaleBy = window.devicePixelRatio, canvas.style.width = canvas.style.height = [options.size, "px"].join(""), canvas.width = canvas.height = options.size * scaleBy, ctx.scale(scaleBy, scaleBy)), ctx.translate(options.size / 2, options.size / 2), ctx.rotate((options.rotate / 180 - .5) * Math.PI);
        var radius = (options.size - options.lineWidth) / 2;

        function drawCircle(color, lineWidth, percent) {
            percent = Math.min(Math.max(0, percent || 1), 1), ctx.beginPath(), ctx.arc(0, 0, radius, 0, 2 * Math.PI * percent, !1), ctx.strokeStyle = color, ctx.lineWidth = lineWidth, ctx.stroke()
        }

        function drawBackground() {
            options.scaleColor && function () {
                var offset, length, i = 24;
                for (ctx.lineWidth = 1, ctx.fillStyle = options.scaleColor, ctx.save(), i = 24; 0 < i; --i) offset = i % 6 == 0 ? (length = options.scaleLength, 0) : (length = .6 * options.scaleLength, options.scaleLength - length), ctx.fillRect(-options.size / 2 + offset, 0, length, 1), ctx.rotate(Math.PI / 12);
                ctx.restore()
            }(), options.trackColor && drawCircle(options.trackColor, options.lineWidth)
        }

        options.scaleColor && options.scaleLength && (radius -= options.scaleLength + 2), Date.now = Date.now || function () {
            return +new Date
        };
        var reqAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
            window.setTimeout(callback, 1e3 / 60)
        };
        this.clear = function () {
            ctx.clearRect(options.size / -2, options.size / -2, options.size, options.size)
        }, this.draw = function (percent) {
            var color;
            options.scaleColor || options.trackColor ? ctx.getImageData && ctx.putImageData ? cachedBackground ? ctx.putImageData(cachedBackground, 0, 0) : (drawBackground(), cachedBackground = ctx.getImageData(0, 0, options.size * scaleBy, options.size * scaleBy)) : (this.clear(), drawBackground()) : this.clear(), ctx.lineCap = options.lineCap, color = "function" == typeof options.barColor ? options.barColor(percent) : options.barColor, 0 < percent && drawCircle(color, options.lineWidth, percent / 100)
        }.bind(this), this.animate = function (from, to) {
            var startTime = Date.now();
            options.onStart(from, to);
            var animation = function () {
                var process = Math.min(Date.now() - startTime, options.animate),
                    currentValue = options.easing(this, process, from, to - from, options.animate);
                this.draw(currentValue), options.onStep(from, to, currentValue), process >= options.animate ? options.onStop(from, to) : reqAnimationFrame(animation)
            }.bind(this);
            reqAnimationFrame(animation)
        }.bind(this)
    }

    function EasyPieChart(el, opts) {
        var defaultOptions = {
            barColor: "#ef1e25",
            trackColor: "#f9f9f9",
            scaleColor: "#dfe0e0",
            scaleLength: 5,
            lineCap: "round",
            lineWidth: 3,
            size: 110,
            rotate: 0,
            animate: 1e3,
            easing: function (x, t, b, c, d) {
                return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b
            },
            onStart: function (from, to) {
            },
            onStep: function (from, to, currentValue) {
            },
            onStop: function (from, to) {
            }
        };
        defaultOptions.renderer = CanvasRenderer;
        var options = {}, currentValue = 0, init = function () {
            for (var i in this.el = el, this.options = options, defaultOptions) defaultOptions.hasOwnProperty(i) && (options[i] = opts && void 0 !== opts[i] ? opts[i] : defaultOptions[i], "function" == typeof options[i] && (options[i] = options[i].bind(this)));
            "string" == typeof options.easing && "undefined" != typeof jQuery && jQuery.isFunction(jQuery.easing[options.easing]) ? options.easing = jQuery.easing[options.easing] : options.easing = defaultOptions.easing, this.renderer = new options.renderer(el, options), this.renderer.draw(currentValue), el.dataset && el.dataset.percent && this.update(parseInt(el.dataset.percent, 10))
        }.bind(this);
        this.update = function (newValue) {
            return newValue = parseInt(newValue, 10), options.animate ? this.renderer.animate(currentValue, newValue) : this.renderer.draw(newValue), currentValue = newValue, this
        }.bind(this), init()
    }

    $.fn.easyPieChart = function (options) {
        return this.each(function () {
            $.data(this, "easyPieChart") || $.data(this, "easyPieChart", new EasyPieChart(this, options))
        })
    }
}(jQuery), function ($) {
    $.yslider = function (el, list, options) {
        var self = this, $el = $(el);

        function slide() {
            self.ul.css({transition: "", top: "-100%"}), setTimeout(function () {
                self.ul.css({transition: "none", top: ""});
                var first = self.ul.children().first();
                first.remove(), self.ul.append(first)
            }, self.options.speed + 10)
        }

        self.options = $.extend({}, $.yslider.defaults, options), self.list = list, self.ul, self.items = [], self.int = 0, function () {
            $el.addClass("y-slider"), $el.empty();
            var div = $("<div>"), maxLen = 0;
            self.ul = $("<ul>");
            for (var i = 0; i < list.length; i++) {
                var word = list[i], item = $("<li>").html(word);
                self.items.push(item), self.ul.append(item), maxLen = Math.max(maxLen, word.length)
            }
            $el.text(Array(maxLen + 1).join("M")).append(div.append(self.ul)), setTimeout(function () {
                self.int = setInterval(slide, self.options.speed + self.options.pause + 10)
            }, self.options.delay)
        }()
    }, $.yslider.defaults = {speed: 100, pause: 300, delay: 0}, $.fn.yslider = function (list, options) {
        return this.each(function () {
            new $.yslider(this, list, options)
        })
    }
}(jQuery);